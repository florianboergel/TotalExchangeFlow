# AUTOGENERATED! DO NOT EDIT! File to edit: 00_tef_core.ipynb (unless otherwise specified).

__all__ = ['constructorTEF']

# Cell
import math
import numpy as np
import xarray as xr
import time

# Cell

class constructorTEF:
    def __init__(self, inputFile, data_description, **kwargs):
        """Creates a constructor object that is passed to the pyTEF functions.

        Args:
            inputFile (str, xr.Dataset, xr.DataArray): If string is passed, function tries to read an netcdf file, otherwise xarray object can be passed as well.
            data_description (dict): Describes the data that is read

        Raises:
            IOError: Could not read filename
            IOError: No filename and invalid xarray object is passed.

        Example:
            data_description = {
                "lon" : None,
                "lat" : "yt_ocean",
                "depth" : "st_ocean",
                "time" : "time"
            }
        """
        if isinstance(inputFile, str):
            try:
                self._read(fileName=inputFile)
            except (OSError, IOError, RunetimeError):
                raise IOError("Could not read file.")
        elif isinstance(inputFile, xr.Dataset):
            self.ds = inputFile
        elif isinstance(inputFile, xr.DataArray):
            self.ds = inputFile
        else:
            raise IOError("Please provide xarray Dataset/DataArray or netcdf-filepath")

        self._setup(data=data_description)

        self.transport = None
        self.tracer = None

    def _read(self, fileName, **kwargs):
        self.ds = xr.open_dataset(filename, use_cftime=True, **kwargs)

    def _setup(self, data):
        """Iterates over keys in dictionary. Handles 4d-data, if one argument is left empty, dummy dimension will be created.

        Args:
            data (dict): Dictionary that describes geospatial dimensions of the dataset.
        """
        for dimension in data.keys():
            if data[dimension] is None:
                self.ds = self.ds.expand_dims(dimension)
            else:
                self.ds = self.ds.rename({data[dimension]: dimension})

        self.ds = self.ds.transpose("time",
                                    "depth",
                                    "lat",
                                    "lon")